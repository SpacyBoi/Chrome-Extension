angular.module('remindersExtension', [
    'remindersExtension.config',
    'remindersExtension.services',
    'remindersExtension.controllers',
    'remindersExtension.directives',
    'remindersExtension.filters',
    'ui.router',
    'ngAnimate',
    'angularMoment'
]);
angular.module('remindersExtension.config', []);
angular.module('remindersExtension.services', ['remindersExtension.config']);
angular.module('remindersExtension.controllers', ['remindersExtension.config', 'remindersExtension.services']);
angular.module('remindersExtension.directives', []);
angular.module('remindersExtension.filters', []);

angular.module('remindersExtension').run(function($rootScope, $transitions, $timeout, moment, extensionService) {

   
    moment.locale(window.navigator.userLanguage || window.navigator.language);


    $transitions.onBefore({}, transitions => {
        const options = transitions.options();

        $rootScope.isBackward = options.custom.backward === true;

        return $timeout(() => {}, 0);
    });

    
    $rootScope.$on('remindersCountUpdated', extensionService.setBadgeCounter);
    
    chrome.runtime.onInstalled.addListener(extensionService.transferFromLocalStorage);

});
angular.module('remindersExtension').config(function($stateProvider, $urlRouterProvider) {

    $urlRouterProvider.otherwise('/list');

    $stateProvider
        .state('reminders', {
            url: '',
            abstract: true,
            templateUrl: 'views/base.html',
            resolve: {
                config: function(settingsService) {
                    return new Promise((resolve, reject) => {
                        settingsService.getConfig(config => {
                            resolve(config);
                        });
                    });
                }
            }
        })
        .state('reminders.list', {
            url: '/list',
            views: {
                'content': {
                    templateUrl: 'views/list.html',
                    controller: 'ListController'
                }
            }
        })
        .state('reminders.new', {
            url: '/new',
            views: {
                'content': {
                    templateUrl: 'views/reminder.html',
                    controller: 'ReminderController'
                }
            },
            resolve: {
                reminder: function(config, remindersService) {
                    return remindersService.create(config);
                }
            }
        })
        .state('reminders.new.repeat', {
            url: '/repeat',
            views: {
                'content@reminders': {
                    templateUrl: 'views/repeat.html',
                    controller: 'ReminderController'
                }
            },
            resolve: {
                reminder: function($state, remindersService) {
                    let cache = remindersService.getCache();

                    return cache ? cache : $state.go('reminders.new');
                }
            }
        })
        .state('reminders.edit', {
            url: '/edit/:reminderId',
            views: {
                'content': {
                    templateUrl: 'views/reminder.html',
                    controller: 'ReminderController'
                }
            },
            resolve: {
                reminder: function($state, $stateParams, ReminderModel) {
                   
                    if (!$stateParams.reminderId) {
                        return $state.go('reminders.list');
                    }

                   
                    return new Promise((resolve, reject) => {
                        ReminderModel.find($stateParams.reminderId, reminder => {
                            if (!reminder) {
                                return $state.go('reminders.list');
                            }

                            resolve(reminder);
                        });
                    });
                }
            }
        })
        .state('reminders.edit.repeat', {
            url: '/repeat',
            views: {
                'content@reminders': {
                    templateUrl: 'views/repeat.html',
                    controller: 'ReminderController'
                }
            },
            resolve: {
                reminder: function($state, $stateParams, remindersService) {
                    let cache = remindersService.getCache();

                    return cache ? cache : $state.go('reminders.edit', {
                        reminderId: $stateParams.reminderId
                    });
                }
            }
        })
        .state('reminders.settings', {
            url: '/settings',
            views: {
                'content': {
                    templateUrl: 'views/settings.html',
                    controller: 'SettingsController'
                }
            }
        })
        .state('reminders.settings.sound', {
            url: '/sound',
            views: {
                'content@reminders': {
                    templateUrl: 'views/settings.sound.html',
                    controller: 'SettingsController'
                }
            }
        })
        .state('reminders.settings.defaultReminder', {
            url: '/defaultReminder',
            views: {
                'content@reminders': {
                    templateUrl: 'views/settings.defaultReminder.html',
                    controller: 'SettingsController'
                }
            }
        })
        .state('eventPage', {
            url: '/eventPage',
            controller: 'EventPageController'
        })
    ;
}); 
angular.module('remindersExtension.controllers').controller('EventPageController', function($rootScope, extensionService, remindersService) {
    
    chrome.alarms.onAlarm.addListener(remindersService.activate);
    chrome.notifications.onButtonClicked.addListener(remindersService.notificationOnButtonClickHandler);
    chrome.notifications.onClosed.addListener(remindersService.notificationOnClosedHandler);
    chrome.storage.onChanged.addListener((changes, namespace) => {
        $rootScope.$broadcast('remindersCountUpdated');
        remindersService.emitRemindersUpdatedEvent();
        remindersService.synchronizeReminders(changes);
    });

    extensionService.setContextMenu();
    extensionService.setBadgeCounter();
    remindersService.checkRemindersIntegrity();

});
angular.module('remindersExtension.controllers').controller('ExtensionController', function($scope, settingsService, remindersService) {
    settingsService.getConfig(config => {
        $scope.config = config;
    });

    remindersService.cleanCache();
});
angular.module('remindersExtension.controllers').controller('ListController', function($rootScope, $scope, moment, config, ReminderModel, extensionService, remindersService) {

    $scope.currentList = 'active';

    //
    $scope.isActiveList     = () => $scope.currentList === 'active';
    $scope.isPastList       = () => $scope.currentList === 'past';
    $scope.isLowPriority    = reminder => reminder.priority === ReminderModel.PriorityType.LOW;
    $scope.isMediumPriority = reminder => reminder.priority === ReminderModel.PriorityType.MEDIUM;
    $scope.isHighPriority   = reminder => reminder.priority === ReminderModel.PriorityType.HIGH;

    /**
     * 
     */
    function fillRemindersList() {
        remindersService.getList(reminders => {
            $scope.activeReminders = reminders.active;
            $scope.pastReminders = reminders.past;
            $scope.$apply();
        });
    }

    $scope.toggleList = () => {
        $scope.currentList = $scope.currentList === 'active' ? 'past' : 'active';
    };

    /**
     * 
     *
     * @param {ReminderModel} reminder
     */
    $scope.remove = reminder => {
        let reminders = !reminder.isPast() ? $scope.activeReminders : $scope.pastReminders;
        let index = reminders.indexOf(reminder);

        reminder.remove();
        reminders.splice(index, 1);
    };

    /**
     * 
     * 
     *
     * @param {ReminderModel} reminder
     *
     * @return {string}
     */
    $scope.formatTime = reminder => {
        let localeTimeString = new Date().toLocaleTimeString();
        let isTwelveHours = localeTimeString.match(/am|pm/i) !== null;
        let format = isTwelveHours ? 'h:mm A' : 'HH:mm';

        return moment(reminder.activateAt).format(format);
    };

    /**
     * 
     *
     * @param {ReminderModel} reminder

     * @return {string}
     */
    $scope.formatDate = reminder => {
        return moment(reminder.activateAt).fromNow(true);
    };

    fillRemindersList();

    
    remindersService.onRemindersUpdatedEvent(() => {
        fillRemindersList();
    });

});
angular.module('remindersExtension.controllers').controller('ReminderController', function($scope, $state, $stateParams, $transitions, $timeout, moment, reminder, extensionService, remindersService, settingsService, ReminderModel) {

    let goToMainList    = () => $state.go('reminders.list', {}, { custom: { backward: true } });
    let isEditingPage   = reminder.id !== null;

    
    $scope.reminder         = reminder;
    $scope.types            = ReminderModel.Type;
    $scope.repeatPeriods    = ReminderModel.RepeatPeriodType;
    $scope.priorities       = ReminderModel.PriorityType;

    
    $scope.isEditing        = () => isEditingPage;
    $scope.isText           = () => $scope.reminder.type === ReminderModel.Type.TEXT;
    $scope.isNotification   = () => $scope.reminder.type === ReminderModel.Type.NOTIFICATION;
    $scope.isTab            = () => $scope.reminder.type === ReminderModel.Type.TAB;
    $scope.isTask           = () => $scope.reminder.type === ReminderModel.Type.TASK;

    /**
     * 
     */
    $scope.done = () => {
        $scope.reminder.persist();
        remindersService.cleanCache();
        goToMainList();
    };

    /**
     * 
     */
    $scope.save = () => {
        $scope.reminder.persist();
        goToMainList();
    };

    /**
     * 
     */
    $scope.isFormValid = reminderForm => {
        
        if ($scope.reminder.repeat === $scope.repeatPeriods.CUSTOM.value &&
            $scope.reminder.repeatEvery === undefined
        ) {
            return false;
        }

        return reminderForm.$valid;
    };
    
    /**
     * 
     *
     */
    $scope.playSound = () => {
        if ($scope.reminder.sound) {
            settingsService.playSound();
        }
    };

     
    $scope.$watch(
        'reminder',
        () => remindersService.setCache($scope.reminder),
        true
    );

    
    $scope.$watch('reminder.repeat', (newValue, oldValue) => {
        let repeatPeriods = ReminderModel.RepeatPeriodType;


        if (newValue !== repeatPeriods.NEVER.value) {
            $scope.reminder.autoRemove = false;
        }


        if (newValue === repeatPeriods.CUSTOM.value) {

            let ms = newValue === oldValue ? 500 : 0;

 
            $timeout(() => {
                document.querySelector('#repeat-custom-minutes').scrollIntoView();
            }, ms);
        }
    });

    
    $scope.$watch('reminder.type', type => {

        if (type === ReminderModel.Type.TASK ||
            type === ReminderModel.Type.TEXT
        ) {
            $scope.reminder.repeat = $scope.repeatPeriods.NEVER.value;
        }
    });


    $transitions.onStart({}, trans => {
        const exceptions = [
            'reminders.new',
            'reminders.new.repeat',
            'reminders.edit',
            'reminders.edit.repeat'
        ];

        if (exceptions.indexOf(trans.$to().name) === -1) {
            remindersService.cleanCache();
        }
    });

});
angular.module('remindersExtension.controllers').controller('SettingsController', function($rootScope, $scope, $state, config, ReminderModel, extensionService, settingsService) {

    $scope.config               = config;
    $scope.sounds               = settingsService.getSounds();
    $scope.manifest             = chrome.runtime.getManifest();
    $scope.locale               = window.navigator.userLanguage || window.navigator.language;
    $scope.popupSizes           = settingsService.PopupSizeType;
    $scope.sortProperties       = settingsService.SortPropertyType;
    $scope.reminderTypes        = ReminderModel.Type;
    $scope.reminderPriorities   = ReminderModel.PriorityType;


    $scope.reset = () => {
        let c = confirm(chrome.i18n.getMessage('settings_reset_confirmation'));

        if (!c) return;

        settingsService.reset(() => {
            alert(chrome.i18n.getMessage('settings_reset_success'));
            window.location.reload();
        });
    };


    $scope.$watch('config', () => {
        settingsService.setConfig($scope.config);
    }, true);


    $scope.$watch('config.displayCounter', () => {
        $rootScope.$emit('remindersCountUpdated');
    });


    $scope.$watch('config.sound', (newSound, oldSound) => {

        if (newSound !== oldSound) {
            settingsService.playSound(newSound);
        }
    });

});
angular
    .module('remindersExtension.directives')
    .directive('datetimeTransformer', function(moment) {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function($scope, element, attributes, model) {

                
                model.$formatters.push(timestamp => {
                    if (!timestamp) return;

                    return new Date(moment(timestamp).format('YYYY-MM-DDTHH:mm'));
                });

                
                model.$parsers.push(datetime => {
                    if (!datetime) return;

                    return datetime.getTime();
                });
            }
        };
    })
;
angular
    .module('remindersExtension.directives')
    .directive('reminderListItem', function () {

        const items = [];

        function initItems() {
            items.forEach(item => {
                item._isOpening = false;
                item._startPosition = null;
                item._startShift = null;
                item._isOpened = false;
            });
        }

        /**
         *
         *
         * @param {object} item
         *
         * @return {int}
         */
        function getShift(item) {
            let matches = item.css('transform').match(/translateX\(([-0-9]+)px\)/i);

            return matches ? Math.abs(parseInt(matches[1])) : 0;
        }

        /**
         * 
         * 
         *
         * @param {object} item
         *
         * @return {int}
         */
        function getMaxShift(item) {
            let shift = item.parent().prop('offsetWidth') * 0.4;

            return Math.round(shift);
        }

        /**
         *
         *
         * @param {object}  item
         * @param {int}     shift
         * @param {boolean} useTransition
         */
        function setShiftStyle(item, shift, useTransition) {
            let transition = useTransition ? 'transform .2s ease' : 'none';

            item.css('transition', transition);
            item.css('transform', `translateX(-${shift}px)`);
        }

        /**
         * 
         * 
         *
         * @param {object} currentItem
         */
        function closeOpenedItems(currentItem) {
            if (!items) return;

            items.forEach(item => {
                if (item !== currentItem && item._isOpened) {
                    item._isOpened = false;
                    item._startPosition = null;
                    item._startShift = null;

                    setShiftStyle(item, 0, true);
                }
            });
        }

        /**
         * 
         * 
         *
         * @param {Event}   event
         * @param {object}  item
         */
        function setMovementDirection(event, item) {
            if (event.movementX === 0) {
                return;
            }

            item._isOpening = event.movementX < 0;
        }

        /**
         *
         * @param {Event}   event
         * @param {object}  item
         */
        function mouseMoveHandler(event, item) {
            closeOpenedItems(item);
            setMovementDirection(event, item);

            !item._startPosition ? item._startPosition = event.x : null;
            !item._startShift ? item._startShift = getShift(item) : null;

            let maxShift = getMaxShift(item);
            let offsetX = event.x - item._startPosition;
            let newShift = item._startShift - offsetX;

            
            if (newShift >= 0 && newShift <= maxShift) {
                setShiftStyle(item, newShift, false);
            }
        }

        /**
         *
         * @param {object} item
         */
        function mouseLeaveHandler(item) {
           
            if (!item._startPosition) return;

            let maxShift = getMaxShift(item);
            let shift = item._isOpening ? maxShift : 0;

            setShiftStyle(item, shift, true);

            item._isOpened = shift !== 0;
            item._startPosition = null;
            item._startShift = null;
        }

        return {
            restrict: 'A',
            link: function($scope, element, attributes) {
            
                items.push(element);

                element.on('mousedown', (event) => {
                    
                    if (event.buttons !== 1) return;

                    element.on('mousemove', (event) => mouseMoveHandler(event, element));
                });

                element.on('mouseup', () => {
                    element.off('mousemove');
                    mouseLeaveHandler(element);
                });

                element.on('mouseleave', () => mouseLeaveHandler(element));

                
                if ($scope.$last) {
                    initItems();
                }
            }
        };
    })
;
angular
    .module('remindersExtension.directives')
    .directive('urlTransformer', function () {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function($scope, element, attributes, model) {
                const defProtocol = 'http://';
                const regex = /^[a-z]+\:\/\//i;

                $scope.urlProtocol = defProtocol;

             
                model.$formatters.push(url => {
                    if (!url) return;

                    $scope.urlProtocol = url.match(regex)[0];
                    url = url.replace(regex, '');

                    return url;
                });

                
                model.$parsers.push((url) => {
                
                    if (!url) {
                        $scope.urlProtocol = defProtocol;
                        return;
                    }

                    
                    let matches = url.match(regex);

                    if (matches && matches[0].length !== url.length) {
                        $scope.urlProtocol = matches[0];
                        url = url.replace(regex, '');

                        model.$setViewValue(url);
                        model.$render();
                    }

                    return $scope.urlProtocol + url;
                });
            }
        };
    })
;
angular
    .module('remindersExtension.filters')
    .filter('i18n', function() {
        return function(message) {
            return chrome.i18n ? chrome.i18n.getMessage(message) : message;
        };
    })
;

angular
    .module('remindersExtension.filters')
    .filter('removeProtocol', function() {
        return function(url) {
            return url.replace(/(^\w+:|^)\/\//, '');
        };
    })
;

angular.module('remindersExtension.services').factory('ReminderModel', function($rootScope, orderByFilter, moment, settingsService) {

 
    const TYPES = {
        TEXT:           '1',
        NOTIFICATION:   '2',
        TAB:            '3',
        TASK:           '4'
    };

  
    const REPEAT_PERIODS = {
        NEVER: {
            value:      'never',
            minutes:    0
        },
        HOURLY: {
            value:      'hourly',
            minutes:    60
        },
        DAILY: {
            value:      'daily',
            minutes:    1440
        },
        WEEKLY: {
            value:      'weekly',
            minutes:    10080
        },
        MONTHLY: {
            value:      'monthly',
            minutes:    43800
        },
        YEARLY: {
            value:      'yearly',
            minutes:    525600
        },
        CUSTOM: {
            value:      'custom',
            minutes:    0
        }
    };

    
    const PRIORITIES = {
        NONE:   '1',
        LOW:    '2',
        MEDIUM: '3',
        HIGH:   '4'
    };

    /**
     * 
     * 
     * @param {object} data 
     * 
     * @constructor
     */
    const Reminder = function(data) {

        this.id             = null;
        this.type           = TYPES.TEXT;
        this.text           = null;
        this.url            = null;
        this.activeTab      = true;
        this.activateAt     = Date.now();
        this.repeat         = REPEAT_PERIODS.NEVER.value;
        this.repeatEvery    = 10;
        this.priority       = PRIORITIES.NONE;
        this.sound          = true;
        this.autoRemove     = false;
        this.createdAt      = null;

        
        if (typeof data === 'object') {
            angular.extend(this, data);
        }
    };

    /**
     *
     * @return {boolean}
     */
    Reminder.prototype.isPast = function() {

        if (this.type === TYPES.TEXT || !this.activateAt) {
            return false;
        }

        let now = Date.now();
        let diff = this.activateAt - now;

        return diff < 0;
    };

    /**
     */
    Reminder.prototype.persist = function() {
        if (!this.id) {
            this.id = btoa(Math.random()).substring(3, 13);
            this.createdAt = Date.now();
        }

        let storageObject = {};

        storageObject[`reminder-${this.id}`] = this;

     
        chrome.storage.sync.set(storageObject);
    };

    /**
     * 
     */
    Reminder.prototype.remove = function() {
        chrome.storage.sync.remove(`reminder-${this.id}`);
    };

    
    Reminder.prototype.activate = function() {
       
        if (this.type === TYPES.NOTIFICATION) {
            settingsService.getConfig(config => {
                chrome.notifications.create(`notification-${this.id}`, {
                    type: 'basic',
                    iconUrl: `images/icons/icon_notification_priority_${this.priority}.png`,
                    title: chrome.i18n.getMessage('notification_reminder'),
                    message: this.text,
                    requireInteraction: config.keepNotification
                });
            });
        }

       
        if (this.type === TYPES.TAB) {
            chrome.tabs.create({
                url: this.url,
                active: this.activeTab
            });
        }

        
        if (this.type === TYPES.TASK) {
            chrome.notifications.create(`task-${this.id}`, {
                type: 'basic',
                iconUrl: `images/icons/icon_notification_priority_${this.priority}.png`,
                title: chrome.i18n.getMessage('notification_task'),
                message: this.text,
                buttons: [
                    { title: chrome.i18n.getMessage('notification_done') },
                    { title: chrome.i18n.getMessage('notification_postpone') }
                ],
                requireInteraction: true
            });
        }

        
        if (this.sound) {
            settingsService.playSound();
        }

        
        if (this.autoRemove &&
            this.repeat === REPEAT_PERIODS.NEVER.value &&
            this.type !== TYPES.TASK
        ) {
            this.remove();
        }

       
        let repeatPeriod = this.getRepeatPeriod();

        if (repeatPeriod !== null) {
            this.activateAt += repeatPeriod * 60000;
            this.persist();
        }

       
        chrome.storage.onChanged.dispatch();
    };

    /**
     *
     * @return {null|int}
     */
    Reminder.prototype.getRepeatPeriod = function() {
        
        if (this.repeat === REPEAT_PERIODS.NEVER.value) {
            return null;
        }

        
        if (this.repeat === REPEAT_PERIODS.CUSTOM.value) {
            return this.repeatEvery;
        }

        
        return REPEAT_PERIODS[this.repeat.toUpperCase()].minutes;
    };

    /**
     */
    Reminder.prototype.postpone = function() {
        settingsService.getConfig(config => {
            this.activateAt = Date.now() + config.postpone * 60000;
            this.persist();
        });
    };

    /**
     */
    Reminder.prototype.syncAlarm = function() {
        if ((this.type !== TYPES.NOTIFICATION &&
            this.type !== TYPES.TAB &&
            this.type !== TYPES.TASK) || this.isPast()
        ) {
            chrome.alarms.clear(`reminder-${this.id}`);

            return;
        }

        let alarmParams = {
            when: this.activateAt
        };
        let repeatPeriod = this.getRepeatPeriod();

        if (repeatPeriod !== null && this.type !== TYPES.TASK) {
            alarmParams.periodInMinutes = repeatPeriod;
        }

        chrome.alarms.create(`reminder-${this.id}`, alarmParams);
    };

    /**
     *
     * @param {string}      reminderId
     * @param {function}    callback
     */
    Reminder.find = function(reminderId, callback) {
        chrome.storage.sync.get(`reminder-${reminderId}`, results => {
            let reminder = results[`reminder-${reminderId}`];
            let r = Object.keys(results).length ? new Reminder(reminder) : null;

            callback(r);
        });
    };

    /**
     *
     * @param {function}    callback
     * @param {=object}     sortParams
     */
    Reminder.findAll = function(callback, sortParams) {
        sortParams = sortParams !== undefined ? sortParams : null;

        chrome.storage.sync.get(null, data => {
            let reminders = [];
            let keys = Object.keys(data);

            keys.forEach(key => {
                if (!/^reminder-/.test(key)) {
                    return;
                }

                let reminder = data[key];
                if (reminder.type === TYPES.TEXT) {
                    reminder.activateAt = null;
                }

                reminders.push(new Reminder(reminder));
            });

            if (reminders.length > 1) {
                return settingsService.getConfig(config => {
                    callback(
                        orderByFilter(reminders, config.sortBy, config.descending)
                    );
                });
            }

            callback(reminders);
        });
    };

    /**
     *
     * @param {function} callback
     */
    Reminder.getCount = function(callback) {
        let active = 0;
        let past = 0;

        Reminder.findAll(reminders => {
            reminders.forEach(reminder => {
                reminder.isPast() ? past++ : active++;
            });

            callback({ active, past })
        });
    };

    Reminder.Type = TYPES;
    Reminder.RepeatPeriodType = REPEAT_PERIODS;
    Reminder.PriorityType = PRIORITIES;

    return Reminder;
});
angular.module('remindersExtension.services').service('extensionService', function(ReminderModel, settingsService) {
    
    /**
     */
    this.setBadgeCounter = function() {
        chrome.browserAction.setBadgeBackgroundColor({ color: '#007AFF' });

        ReminderModel.getCount(counters => {
            settingsService.getConfig(config => {
                let text = counters.active < 1 || !config.displayCounter ? '' : counters.active.toString();

                chrome.browserAction.setBadgeText({
                    text: text
                });
            });
        });
    };

    /**
     */
    this.setContextMenu = function() {
        chrome.contextMenus.create({
            id: 'remindersContextMenuItem',
            contexts: ['page'],
            type: chrome.contextMenus.ItemType.NORMAL,
            title: chrome.i18n.getMessage('extension_contextMenuLabel')
        });

        chrome.contextMenus.onClicked.addListener(() => {
            chrome.tabs.create({
                url: chrome.extension.getURL('/index.html#!/new'),
                active: true
            });
        });
    };

    /**
     *
     * @param {object} details
     */
    this.transferFromLocalStorage = function(details) {
        if (details.previousVersion != "1.0.1" ||
            details.reason != 'update'
        ) {
            return;
        }


        chrome.alarms.clearAll(() => {
            let keys = Object.keys(localStorage);

     
            if (keys.length < 1) {
                return;
            }

            keys.forEach(key => {
                let item = JSON.parse(JSON.parse(localStorage.getItem(key)));

           
                if (item.id === undefined) {
                    settingsService.setConfig(item);
                }

                if (item.id !== undefined) {
                   
                    item.activateAt = new Date(item.activateAt).getTime();

                    let reminder = new ReminderModel(item);

                    reminder.persist();
                }
            });

            
            localStorage.clear();
        });
    };

});
angular.module('remindersExtension.services').service('remindersService', function($rootScope, ReminderModel) {

    let cachedReminder = null;
    
    /**
     *
     * @param {object} config
     *
     * @return {ReminderModel}
     */
    this.create = function(config) {
      
        if (this.getCache()) {
            return this.getCache();
        }

        return new ReminderModel({
            type:       config.defaultType,
            sound:      config.defaultSound,
            autoRemove: config.defaultRemove,
            priority:   config.defaultPriority
        });
    };

    /**
     *
     * @param {function} callback
     */
    this.getList = function(callback) {
        ReminderModel.findAll(reminders => {
            let active = reminders.filter(r => !r.isPast());
            let past = reminders.filter(r => r.isPast());

            callback({ active, past });
        });
    };

    /**
     *
     * @param {Alarm} alarm
     */
    this.activate = function(alarm) {
        let reminderId = alarm.name.split('-')[1];

        ReminderModel.find(reminderId, reminder => {
            if (!reminder) {
                return;
            }

            reminder.activate();
        });
    };

    /**
     *
     * @param {ReminderModel} reminder
     */
    this.setCache = function(reminder) {
        cachedReminder = reminder;
    };

    /**
     *
     * @return {ReminderModel}
     */
    this.getCache = function() {
        return cachedReminder;
    };

    /**
     */
    this.cleanCache = function() {
        cachedReminder = null;
    };

    /**
     *
     * @param {object} changes
     */
    this.synchronizeReminders = function(changes) {
        for (key in changes) {
            if (key.split('-')[0] != "reminder") {
                continue;
            }

            let storageChange = changes[key];

            let isAdded = storageChange.oldValue === undefined;
            let isRemoved = storageChange.newValue === undefined;
            let isChanged = !isAdded && !isRemoved;


            if (isAdded || isChanged) {
                ReminderModel.find(key.split('-')[1], reminder => {
                    reminder.syncAlarm();
                });
            }

            
            if (isRemoved) {
                chrome.alarms.clear(key);
            }
        }
    };


    this.checkRemindersIntegrity = function() {
        ReminderModel.findAll(reminders => {

            if (reminders.length < 1) {
                chrome.alarms.clearAll();

                return;
            }

     
            reminders.forEach(reminder => {
                reminder.syncAlarm();
            });
        });
    };
    
    /**
     * 
     *
     * @param {string}  notificationId
     * @param {int}     buttonIndex
     */
    this.notificationOnButtonClickHandler = function(notificationId, buttonIndex) {
        let reminderId = notificationId.split('-')[1];

    
        chrome.notifications.clear(notificationId);

        ReminderModel.find(reminderId, reminder => {
            if (!reminder) {
                return;
            }

            // 
            if (buttonIndex === 0 && reminder.autoRemove) {
                reminder.remove();
            }

            // 
            if (buttonIndex === 1) {
                reminder.postpone();
            }
        });
    };

    /**
     * 
     *
     * @param {string}  notificationId
     * @param {boolean} byUser
     */
    this.notificationOnClosedHandler = function(notificationId, byUser) {
        let reminderId = notificationId.split('-')[1];

        if (!byUser) {
            return;
        }

        // 
        ReminderModel.find(reminderId, reminder => {
            // 
            if (!reminder || reminder.type !== ReminderModel.Type.TASK) {
                return;
            }

            reminder.postpone();
        });
    };

    /**
     * 
     */
    this.emitRemindersUpdatedEvent = function() {
        chrome.runtime.sendMessage({
            eventName: 'remindersUpdated'
        });
    };

    /**
     * 
     * @param callback
     */
    this.onRemindersUpdatedEvent = function(callback) {
        chrome.runtime.onMessage.addListener(data => {
            if (data.eventName === 'remindersUpdated') {
                callback();
            }
        });
    };

});
angular.module('remindersExtension.services').service('settingsService', function() {

    
    const POPUP_SIZES = {
        COMPACT:    'compact',
    };

     
    const SORT_PROPERTIES = {
    };

  
    const SOUNDS = [
        'Aurora','Chord','Circles', 'COC', 'CSGO', 'Fanfare', 'Halal', 'Hello', 'Groove','GTA',  'Kahoot',
        'Keys', 'Ladder', 'Note', 'Popcorn', 'Undertale', 'Snap', 'Spell',
        'Spotless', 'Synth', 'Tiptoes', 'Tritone', 'Whatsapp'
    ];

   
    const DEFAULT_CONFIG = {
        displayCounter:     true,
        keepNotification:   true,
        sortBy:             SORT_PROPERTIES.CREATED_AT,
        descending:         true,
        sound:              SOUNDS[4],
        volume:             0.8,
        postpone:           10,
        popupSize:          POPUP_SIZES.COMPACT,
        defaultType:        '1',
        defaultSound:       true,
        defaultRemove:      false,
        defaultPriority:    '1'
    };

    /**
     * 
     *
     * @param {object}      options
     * @param {=function}   callback
     */
    this.setConfig = function(options, callback) {
        let data = {
            'config': angular.extend({}, DEFAULT_CONFIG, options)
        };

        chrome.storage.sync.set(data, () => {
            if (callback !== undefined) {
                callback();
            }
        });
    };

    /**
     * 
     *
     * @param {function} callback
     */
    this.getConfig = function(callback) {
        chrome.storage.sync.get('config', data => {
            let extendedConfig = angular.extend({}, DEFAULT_CONFIG, data['config']);

            callback(extendedConfig);
        });
    };

    /**
     * 
     *
     * @param {=string} requestedSound
     * @returns {object|array}
     */
    this.getSounds = function(requestedSound) {
        const soundObjects = [];

        requestedSound = requestedSound !== undefined ? requestedSound : null;

        SOUNDS.forEach(sound => {
            let soundObj = {
                code: sound,
                title: sound.replace(/([A-Z])/g, ' $1').trim(),
                file: `audio/${sound}.mp3`
            };

            soundObjects.push(soundObj);

            // If there was requested just a particular sound then return it
            if (requestedSound && requestedSound === sound) {
                requestedSound = soundObj;
            }
        });

        return requestedSound || soundObjects;
    };

    /**
     * 
     * 
     *
     * @param {=string} soundCode
     */
    this.playSound = function(soundCode) {
        this.getConfig(config => {
            const sound = soundCode !== undefined ? this.getSounds(soundCode) : this.getSounds(config.sound);
            const audio = new Audio(sound.file);

            audio.volume = config.volume;
            audio.play();
        });
    };

    /**
     * 
     *
     * @param {function} callback
     */
    this.reset = function(callback) {
        chrome.alarms.clearAll(wasCleared => {
            // If something went wrong with clearing the alarms
            if (!wasCleared) {
                throw Error('Something went wrong')
            }

            chrome.storage.sync.clear(callback);
        });
    };

    // 
    this.PopupSizeType = POPUP_SIZES;
    this.SortPropertyType = SORT_PROPERTIES;

});